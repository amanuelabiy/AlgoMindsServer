import inspect
from collections import deque
import sys
import json


class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self,val=0, left= None,right =None):
        self.val = val
        self.left = left
        self.right = right

def list_to_tree(arr):
    """Creates a binary tree from a list using level order insertion (BFS)."""
    if not arr:
        return None

    root = TreeNode(arr[0])
    queue = deque([root])
    index = 1

    while queue and index < len(arr):
        node = queue.popleft()
        
        if arr[index] is not None:
            node.left = TreeNode(arr[index])
            queue.append(node.left)
        index += 1

        if index < len(arr) and arr[index] is not None:
            node.right = TreeNode(arr[index])
            queue.append(node.right)
        index += 1

    return root

def tree_to_list(root):
    """Converts a binary tree back into a list (level order traversal)."""
    if not root:
        return []
    
    result = []
    queue = deque([root])

    while queue:
        node = queue.popleft()
        if node:
            result.append(node.val)
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append(None)

    # Trim trailing None values
    while result and result[-1] is None:
        result.pop()

    return result

def list_to_linkedlist(arr):
    """Creates a linked list from a list."""
    if not arr:
        return None

    head = ListNode(arr[0])
    current = head
    for val in arr[1:]:
        current.next = ListNode(val)
        current = current.next

    return head

def linkedlist_to_list(head):
    """Converts a linked list back to a list."""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

def process_input(data):
        d = data["input"]
        if data["type"] == "ARRAY_AND_TARGET":
            return (d["arr"], d["target"])
        elif data["type"] == "ARRAY_ONLY":
            return (d["arr"],)
        elif data["type"] == "SINGLE_INTEGER":
            return (d["num"],)
        elif data["type"] == "DOUBLE_INTEGER":
            return (d["num1"], d["num2"])
        elif data["type"] == "SINGLE_STRING":
            return (d["s"],)
        elif data["type"] == "DOUBLE_STRING":
            return (d["s1"], d["s2"])
        elif data["type"] == "ARRAY_AND_STRING":
            return (d["arr"], d["s"])
        elif data["type"] == "TWO_ARRAYS":
            return (d["arr1"], d["arr2"])
        elif data["type"] == "LINKED_LIST":
            head = list_to_linkedlist(d["list"])
            return (head,)
        elif data["type"] == "TREE":
            root = list_to_tree(d["list"])
            return (root,)  # Fix: Ensure it returns a tuple
        else:
            return "unknown_input_type"

    # Code Snippet START ====================

    
    
    # Code Snippet END ====================
def main():
    testcase_json = sys.stdin.read().strip()  # Read all input from stdin
    testcase = json.loads(testcase_json)  # Parse JSON into a Python dictionar

    # Add your main code here
    methods = [name for name, func in inspect.getmembers(Solution, predicate=inspect.isfunction)]
    first_method_name = methods[0] if methods else None

    if first_method_name:
        obj = Solution()  # Create an instance
        method = getattr(obj, first_method_name)  # Retrieve method
        result = method(*process_input(testcase))  # Call the method
        print(result)
        if result == testcase["output"]:
            print("Yay")
        else:
            print("Error")

if __name__ == "__main__":
    main()

