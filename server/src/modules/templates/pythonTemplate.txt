import inspect
from collections import deque
import sys
import json


class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self,val=0, left= None,right =None):
        self.val = val
        self.left = left
        self.right = right

def list_to_tree(arr):
    """Creates a binary tree from a list using level order insertion (BFS)."""
    if not arr:
        return None

    root = TreeNode(arr[0])
    queue = deque([root])
    index = 1

    while queue and index < len(arr):
        node = queue.popleft()
        
        if arr[index] is not None:
            node.left = TreeNode(arr[index])
            queue.append(node.left)
        index += 1

        if index < len(arr) and arr[index] is not None:
            node.right = TreeNode(arr[index])
            queue.append(node.right)
        index += 1

    return root

def tree_to_list(root):
    """Converts a binary tree back into a list (level order traversal)."""
    if not root:
        return []
    
    result = []
    queue = deque([root])

    while queue:
        node = queue.popleft()
        if node:
            result.append(node.val)
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append(None)

    # Trim trailing None values
    while result and result[-1] is None:
        result.pop()

    return result

def list_to_linkedlist(arr):
    """Creates a linked list from a list."""
    if not arr:
        return None

    head = ListNode(arr[0])
    current = head
    for val in arr[1:]:
        current.next = ListNode(val)
        current = current.next

    return head

def linkedlist_to_list(head):
    """Converts a linked list back to a list."""
    result = []
    while head:
        result.append(head.val)
        head = head.next
    return result

class InputProcesser:
     def process_input(self, data):
        d = data['input']
        if data['type'] == "array_and_target":
            return (d['arr'], d['target'])
        elif data['type'] == "array_only":
            return (d['arr'],)
        elif data['type'] == "single_integer":
            return (d['num'],)
        elif data['type'] == "two_integers":
            return (d['num1'], d['num2'])
        elif data['type'] == "single_string":
            return (d['s'],)
        elif data['type'] == "two_strings":
            return (d['s1'], d['s2'])
        elif data['type'] == "array_and_string":
            return (d['arr'], d['s'])
        elif data['type'] == "two_arrays":
            return (d['arr1'], d['arr2'])
        elif data['type'] == "linked_list":
            head = list_to_linkedlist(d['list'])
            return (head,)
        elif data['type'] == "tree":
            root = list_to_tree(d['list'])
            return root
        else:
            return "unknown_input_type"

    # Code Snippet START ====================

    
    
    # Code Snippet END ====================
def main():
    testcase_json = sys.stdin.read().strip()  # Read all input from stdin
    testcase = json.loads(testcase_json)  # Parse JSON into a Python dictionar

    # Add your main code here
    methods = [name for name, func in inspect.getmembers(Solution, predicate=inspect.isfunction)]
    first_method_name = methods[0] if methods else None

    if first_method_name:
        obj = Solution()  # Create an instance
        inp = InputProcesser()
        method = getattr(obj, first_method_name)  # Retrieve method
        result = method(*inp.process_input(testcase))  # Call the method
        if result == testcase["output"]:
            print("Yay")
        else:
            print("Error")

if __name__ == "__main__":
    main()

